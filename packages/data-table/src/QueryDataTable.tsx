import {SpinnerPane} from '@sqlrooms/ui';
import {
  escapeId,
  exportToCsv,
  getColValAsNumber,
  useDuckDb,
} from '@sqlrooms/duckdb';
import {genRandomStr} from '@sqlrooms/utils';
import {PaginationState, SortingState} from '@tanstack/table-core';
import {FC, Suspense, useEffect, useMemo, useState} from 'react';
import DataTablePaginated from './DataTablePaginated';
import useArrowDataTable from './useArrowDataTable';

export type QueryDataTableProps = {
  query: string;
  queryKeyComponents?: unknown[];
};

const QueryDataTable: FC<QueryDataTableProps> = ({query}) => {
  const {conn} = useDuckDb();
  const [sorting, setSorting] = useState<SortingState>([]);
  const [pagination, setPagination] = useState<PaginationState>({
    pageIndex: 0,
    pageSize: 100,
  });

  const [count, setCount] = useState<number | undefined>(undefined);
  const [data, setData] = useState<any>(null);
  const [isFetching, setIsFetching] = useState(false);
  const [isExporting, setIsExporting] = useState(false);

  // Sanitize the query generated by LLM to remove trailing semicolons, comments, and extra spaces
  const sanitizedQuery = useMemo(() => {
    return query
      .trim() // Remove leading/trailing whitespace
      .replace(/;+$/, '') // Remove all trailing semicolons
      .replace(/--.*$/gm, '') // Remove single-line comments
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove multi-line comments
      .replace(/\s+/g, ' '); // Normalize whitespace to single spaces
  }, [query]);

  // Fetch row count
  useEffect(() => {
    const fetchCount = async () => {
      try {
        setIsFetching(true);
        const countQuery = `SELECT COUNT(*)::int FROM (${sanitizedQuery})`;
        const result = await conn.query(countQuery);
        setCount(getColValAsNumber(result));
      } catch (error) {
        console.error('Error fetching count:', error);
      } finally {
        setIsFetching(false);
      }
    };

    fetchCount();
  }, [conn, sanitizedQuery]);

  // Fetch data
  useEffect(() => {
    const fetchData = async () => {
      try {
        setIsFetching(true);
        const result = await conn.query(
          `SELECT * FROM (
            ${sanitizedQuery}
          ) ${
            sorting.length > 0
              ? `ORDER BY ${sorting
                  .map((d) => `${escapeId(d.id)}${d.desc ? ' DESC' : ''}`)
                  .join(', ')}`
              : ''
          }
          OFFSET ${pagination.pageIndex * pagination.pageSize}
          LIMIT ${pagination.pageSize}`,
        );
        setData(result);
      } catch (error) {
        console.error('Error fetching data:', error);
      } finally {
        setIsFetching(false);
      }
    };

    fetchData();
  }, [pagination, sorting, conn, sanitizedQuery]);

  const arrowTableData = useArrowDataTable(data);

  const handleExport = async () => {
    if (!query) return;
    try {
      setIsExporting(true);
      await exportToCsv(query, `export-${genRandomStr(5)}.csv`);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <DataTablePaginated
      {...arrowTableData}
      pageCount={Math.ceil((count ?? 0) / pagination.pageSize)}
      numRows={count}
      isFetching={isFetching}
      pagination={pagination}
      onPaginationChange={setPagination}
      sorting={sorting}
      onSortingChange={setSorting}
      onExport={handleExport}
      isExporting={isExporting}
    />
  );
};

const QueryDataTableWithSuspense: FC<QueryDataTableProps> = (props) => {
  return (
    <Suspense fallback={<SpinnerPane className="w-full h-full" />}>
      <QueryDataTable
        {...props}
        key={props.query} // reset state when query changes
      />
    </Suspense>
  );
};

export default QueryDataTableWithSuspense;
